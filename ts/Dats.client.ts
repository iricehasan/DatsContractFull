/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.7.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { InstantiateMsg, ExecuteMsg, QueryMsg, Addr, CyberSecuritiesResponse, CyberSecurity, DdossesResponse, Ddos, SuperComputersResponse, SuperComputer, VulnerabilitiesResponse, Vulnerability, BlockchainResponse, BlockchainLengthResponse, CyberSecurityResponse, CyberLengthResponse, DdosLengthResponse, DdosResponse, SuperComputerResponse, SuperLengthResponse, VulnerabilityLengthResponse, VulnerabilityResponse } from "./Dats.types";
export interface DatsReadOnlyInterface {
  contractAddress: string;
  getDdossByUser: ({
    user
  }: {
    user: Addr;
  }) => Promise<DdosResponse>;
  getDdosCount: () => Promise<DdosLengthResponse>;
  getAllUserDdosSettings: () => Promise<DdossesResponse>;
  getAllUserSuperComputerSettings: () => Promise<SuperComputersResponse>;
  getSuperComputerByUser: ({
    user
  }: {
    user: Addr;
  }) => Promise<SuperComputerResponse>;
  getSuperComputerCount: () => Promise<SuperLengthResponse>;
  getAllUserCyberSecuritySettings: () => Promise<CyberSecuritiesResponse>;
  getCyberSecurityByUser: ({
    user
  }: {
    user: Addr;
  }) => Promise<CyberSecurityResponse>;
  getCyberSecurityCount: () => Promise<CyberLengthResponse>;
  getAllUserVulnerabilitySettings: () => Promise<VulnerabilitiesResponse>;
  getVulnerabilityByUser: ({
    user
  }: {
    user: Addr;
  }) => Promise<VulnerabilityResponse>;
  getVulnerabilitiyCount: () => Promise<VulnerabilityLengthResponse>;
  getBlockchainByUser: ({
    user
  }: {
    user: Addr;
  }) => Promise<BlockchainResponse>;
  getBlockchainCount: () => Promise<BlockchainLengthResponse>;
}
export class DatsQueryClient implements DatsReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getDdossByUser = this.getDdossByUser.bind(this);
    this.getDdosCount = this.getDdosCount.bind(this);
    this.getAllUserDdosSettings = this.getAllUserDdosSettings.bind(this);
    this.getAllUserSuperComputerSettings = this.getAllUserSuperComputerSettings.bind(this);
    this.getSuperComputerByUser = this.getSuperComputerByUser.bind(this);
    this.getSuperComputerCount = this.getSuperComputerCount.bind(this);
    this.getAllUserCyberSecuritySettings = this.getAllUserCyberSecuritySettings.bind(this);
    this.getCyberSecurityByUser = this.getCyberSecurityByUser.bind(this);
    this.getCyberSecurityCount = this.getCyberSecurityCount.bind(this);
    this.getAllUserVulnerabilitySettings = this.getAllUserVulnerabilitySettings.bind(this);
    this.getVulnerabilityByUser = this.getVulnerabilityByUser.bind(this);
    this.getVulnerabilitiyCount = this.getVulnerabilitiyCount.bind(this);
    this.getBlockchainByUser = this.getBlockchainByUser.bind(this);
    this.getBlockchainCount = this.getBlockchainCount.bind(this);
  }

  getDdossByUser = async ({
    user
  }: {
    user: Addr;
  }): Promise<DdosResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_ddoss_by_user: {
        user
      }
    });
  };
  getDdosCount = async (): Promise<DdosLengthResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_ddos_count: {}
    });
  };
  getAllUserDdosSettings = async (): Promise<DdossesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_all_user_ddos_settings: {}
    });
  };
  getAllUserSuperComputerSettings = async (): Promise<SuperComputersResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_all_user_super_computer_settings: {}
    });
  };
  getSuperComputerByUser = async ({
    user
  }: {
    user: Addr;
  }): Promise<SuperComputerResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_super_computer_by_user: {
        user
      }
    });
  };
  getSuperComputerCount = async (): Promise<SuperLengthResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_super_computer_count: {}
    });
  };
  getAllUserCyberSecuritySettings = async (): Promise<CyberSecuritiesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_all_user_cyber_security_settings: {}
    });
  };
  getCyberSecurityByUser = async ({
    user
  }: {
    user: Addr;
  }): Promise<CyberSecurityResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_cyber_security_by_user: {
        user
      }
    });
  };
  getCyberSecurityCount = async (): Promise<CyberLengthResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_cyber_security_count: {}
    });
  };
  getAllUserVulnerabilitySettings = async (): Promise<VulnerabilitiesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_all_user_vulnerability_settings: {}
    });
  };
  getVulnerabilityByUser = async ({
    user
  }: {
    user: Addr;
  }): Promise<VulnerabilityResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_vulnerability_by_user: {
        user
      }
    });
  };
  getVulnerabilitiyCount = async (): Promise<VulnerabilityLengthResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_vulnerabilitiy_count: {}
    });
  };
  getBlockchainByUser = async ({
    user
  }: {
    user: Addr;
  }): Promise<BlockchainResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_blockchain_by_user: {
        user
      }
    });
  };
  getBlockchainCount = async (): Promise<BlockchainLengthResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_blockchain_count: {}
    });
  };
}
export interface DatsInterface extends DatsReadOnlyInterface {
  contractAddress: string;
  sender: string;
  saveDDos: ({
    isApprove,
    trafficScale
  }: {
    isApprove: boolean;
    trafficScale: number;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  saveSuperComputer: ({
    cpuValue,
    isApprove
  }: {
    cpuValue: number;
    isApprove: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  saveCyberSecurity: ({
    isApprove,
    malwareResearch,
    ransomewareResearch,
    serverSecurity,
    webSecurity
  }: {
    isApprove: boolean;
    malwareResearch: boolean;
    ransomewareResearch: boolean;
    serverSecurity: boolean;
    webSecurity: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  saveVulnerabilitiy: ({
    blockchainPenetration,
    contractPenetration,
    isApprove,
    scadaPenetration,
    serverPenetration,
    webPenetration
  }: {
    blockchainPenetration: boolean;
    contractPenetration: boolean;
    isApprove: boolean;
    scadaPenetration: boolean;
    serverPenetration: boolean;
    webPenetration: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  saveBlockchain: ({
    approveAttackPrevention
  }: {
    approveAttackPrevention: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class DatsClient extends DatsQueryClient implements DatsInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.saveDDos = this.saveDDos.bind(this);
    this.saveSuperComputer = this.saveSuperComputer.bind(this);
    this.saveCyberSecurity = this.saveCyberSecurity.bind(this);
    this.saveVulnerabilitiy = this.saveVulnerabilitiy.bind(this);
    this.saveBlockchain = this.saveBlockchain.bind(this);
  }

  saveDDos = async ({
    isApprove,
    trafficScale
  }: {
    isApprove: boolean;
    trafficScale: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      save_d_dos: {
        is_approve: isApprove,
        traffic_scale: trafficScale
      }
    }, fee, memo, _funds);
  };
  saveSuperComputer = async ({
    cpuValue,
    isApprove
  }: {
    cpuValue: number;
    isApprove: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      save_super_computer: {
        cpu_value: cpuValue,
        is_approve: isApprove
      }
    }, fee, memo, _funds);
  };
  saveCyberSecurity = async ({
    isApprove,
    malwareResearch,
    ransomewareResearch,
    serverSecurity,
    webSecurity
  }: {
    isApprove: boolean;
    malwareResearch: boolean;
    ransomewareResearch: boolean;
    serverSecurity: boolean;
    webSecurity: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      save_cyber_security: {
        is_approve: isApprove,
        malware_research: malwareResearch,
        ransomeware_research: ransomewareResearch,
        server_security: serverSecurity,
        web_security: webSecurity
      }
    }, fee, memo, _funds);
  };
  saveVulnerabilitiy = async ({
    blockchainPenetration,
    contractPenetration,
    isApprove,
    scadaPenetration,
    serverPenetration,
    webPenetration
  }: {
    blockchainPenetration: boolean;
    contractPenetration: boolean;
    isApprove: boolean;
    scadaPenetration: boolean;
    serverPenetration: boolean;
    webPenetration: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      save_vulnerabilitiy: {
        blockchain_penetration: blockchainPenetration,
        contract_penetration: contractPenetration,
        is_approve: isApprove,
        scada_penetration: scadaPenetration,
        server_penetration: serverPenetration,
        web_penetration: webPenetration
      }
    }, fee, memo, _funds);
  };
  saveBlockchain = async ({
    approveAttackPrevention
  }: {
    approveAttackPrevention: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      save_blockchain: {
        approve_attack_prevention: approveAttackPrevention
      }
    }, fee, memo, _funds);
  };
}